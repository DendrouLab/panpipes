# ----------------------- #
# QC pipeline DendrouLab
# ----------------------- #
# written by Charlotte Rich-Griffin, Thom Tomas, Fabiola Curion
# maintained by Charlotte Rich-Griffin

# needs a sample metadata file (see resources for an example)
# will run :
#   summary plots of 10x metrics
#   scrublet scores
#   scanpy QC
#   summary QC plots

# Followed by integration pipeline and clustering pipeline. This pipeline does not perform any filtering,
# this happens as the first stpe in the integration pipeline. See pipeline_integration.yml for details

# Note that if you are combining mutliple datasets from different source the final anndata object will only contain the intersect of the genes
# from all the data sets. For example if the mitochondrial genes have been excluded from one of the inputs, they will be excluded from the final data set.
# In this case it might be wise to run qc separately on each dataset, and them merge them together to create on h5ad file to use as input for
# integration pipeline.
# ------------------------
# compute resource options
# ------------------------
resources:
  # Number of threads used for parallel jobs
  # high = make anndata
  threads_high: 2
  # medium = running scrublet per sample
  threads_medium: 2
  # low = plotting
  threads_low: 1
  

# ------------------------
# Project name and data format
# ------------------------
project: "test"
sample_prefix: "test"
use_existing_h5ad: False

# submission_file format:
# For qc_general the required columns are
# sample_id       path        type
# Example at resources/sample_file_general.txt
# For qc_mm the required columns are
# sample_id  gex_path  gex_filetype  (adt_path  adt_filetype tcr_path  tcr_filetype)
# Example at resources/sample_file_mm.txt
submission_file: sample_caf.tsv
# at the QC stage it can be useful to look at the normalised data on a per channel basis 
# i.e. the 10X channel. This can help determine any inconsistencies in staining per channel and other QC concerns.
# If you want to run clr normalsiation on a per channel basis, then you need to 
# specify which column in your submission file corresponds to the channel
# this is usually the sample_id column (otherwise leave the next parameter blank)
channel_col: sample_id

# which metadata cols from the submission file do you want to include in the anndata object
metadatacols: 

concat_join_type: inner
# Recommended to set to True: this will import each modality as a muon object.
# For more information see Mudata and muon on webpage...
use_muon: True



# ------------------------
# 10X files processing
# ------------------------
plot_10X_metrics: True 
kneeplot: False

#---------------------------------------
# Modalities in the project
#---------------------------------------
# the qc scripts are independent and modalities are processed following this order. Set to True to abilitate modality(ies). 
# Leave empty (None) or False to signal this modality is not in the experiment.

modalities:
  rna: 
  prot: 
  bcr:
  tcr: 
  atac: 

#---------------------------------------
# Demultiplexing with hashtags, chemical tags or lipid tagging
#---------------------------------------
demultiplex:
  include: False # True or False
  metadatacols: ""
# if set to True then the submission file must have a "demultiplex_map_file" column
# The demultiplex map file must have one column called barcode_id and one column called antibody
# (other columns will not be integrated into the anndata object)
# a second demultiplex metadata file path can also be included in submission file
# (column names in samples file: demultiplex_map_file demultiplex_mtd_file)
# the metadata file must contan and antibody column which matches the map file and any other relevent metadata to your samples
# specify which columns you want to keep from the demultiplex mtd file in metadatacols

# Note that if duplicate columns exists in metadatacols and demultiplex_metadata_cols, then 
# for the demultiplexed samples only, the demultiplexing metadata will be included instead of the 
# library level metadata. The advatnage of this is that when you analyse a mixture of multiplexed and 
# not multiplexed libraries any matching metadata will get integrated as one column in the h5ad object.
# But if you have sample level metadata for the multiplexed columns make sure this daata is indicated 
# with a different column name to any in demultiplex_metadatacols.


# ------------
## Doublets on GEX - Scrublet
# ------------
scr:
  run: True
  # The values here are the default values, if you were to leave a paramter pblank, it would default to these value,
  expected_doublet_rate: 0.06
  #the expected fraction of transcriptomes that are doublets, typically 0.05-0.1.
  # Results are not particularly sensitive to this parameter")
  sim_doublet_ratio: 2
  # the number of doublets to simulate, relative to the number of observed transcriptomes.
  # Setting too high is computationally expensive. Min tested 0.5
  n_neighbours: 20
  # Number of neighbors used to construct the KNN classifier of observed transcriptomes
  # and simulated doublets.
  # The default value of round(0.5*sqrt(n_cells)) generally works well.
  min_counts: 2
  # Used for gene filtering prior to PCA. Genes expressed at fewer than `min_counts` in fewer than `min_cells` (see below) are excluded"
  min_cells: 3
  # Used for gene filtering prior to PCA.
  # Genes expressed at fewer than `min_counts` (see above) in fewer than `min_cells` are excluded.")
  min_gene_variability_pctl: 85
  # Used for gene filtering prior to PCA. Keep the most highly variable genes
    # (in the top min_gene_variability_pctl percentile),
    #as measured by the v-statistic [Klein et al., Cell 2015]")
  n_prin_comps: 30
  # Number of principal components used to embed the transcriptomes
  # prior to k-nearest-neighbor graph construction
  use_thr: True
  # use a user defined thr to define min doublet score to split true from false doublets?
  # if false just use what the software produces
  # this threshold applies to plots, a=no actual fitlering takes place.
  call_doublets_thr: 0.25
  #if use_thr is True, this thr will be used to define doublets

# ------------
# GEX QC
# ------------
# this part of the pipeline allows to generate the QC parameters that will be used to 
# evaluate inclusion/ exclusion criteria. Filtering of cells/genes happens in the following pipeline
# pipeline_integration.py.

# leave options blank to avoid running, "default" (the data stored within the package) 
# cell cycle action
# ccgenes will plot the proportions of cell cycle genes (recommended to leave as default)
ccgenes: default
iggenesfile: default
# It's often practical to rely on known gene lists, for a series of tasks, like evaluating % of mitochondrial genes or
# ribosomal genes, or excluding IGG genes from HVG selection. We collect useful gene lists in a file, resources/custom_gene_lists_v1.tsv, 
# and define "actions" on them as follows:
# (for pipeline_qc_mm.py)
# calc_proportions: calculate proportion of reads mapping to X genes over total number of reads, per cell
# score_genes: using scanpy.score_genes function, 
# (for pipeline_integration.py)
# exclude: exclude these genes from the HVG selection, if they are deemed HV.
# plot_markers: plot these genes
# 
# custom genes actions

custom_genes_file: resources/custom_gene_lists_v1.tsv
calc_proportions: haemoglobin,mitochondrial,ribosomal
score_genes: MarkersNeutro

# ------------
#GEX QC metrics
# ------------
plotqc:
  # likely a combination of metadatacolumns and demultiplex_metadatacols
  grouping_var: sample_id
  gex_metrics: doublet_scores,pct_counts_mt,pct_counts_rp,pct_counts_hb,pct_counts_ig


# ------------
# Characterising Background 
# ------------
# This pipeline does not include removal of background contamination as you would with soupX or cellblender.
# However it is useful to chararcterise the background of your gene expression assay and antibody binding assay
# Setting `assess_background` to True will:
# 1. create h5mu from raw data inputs (expected as cellranger h5 or mtx folder, if you do not have this then set to False)
# 2. Plot comparitive QC plots to compare distribution of UMI and feature counts in background and foreground
# 3. Create heatmaps of the top features in the background, so you can compare teh background contaimation per channel
assess_background: False
# if no adt data then exclude column and leave options below blank

# ------------
# ADT qc - requires adt_path to be included in the submission file
# ------------

# As default the qc_mm will choose the first column of the cellranger features.tsv.gz
# To merge extra information about the antibodies e.g. whether they are hashing antibodies or isotypes,
# Create a table with the first column equivalent to the first column of cellrangers features.tsv.gz
# and specify it below (save as txt file)
protein_metadata_table: 
# Make sure there are unique entries in this column for each adt.
# include a column called isotype (containing True or False) if you want to qc isotypes
# include a column called hashing_ab (containing True or False) if your dataset contains hashing antibodies which you wish to split into a separate modality

# If you want to update the mudata index with a column from protein_metadata_table, specify here
# If there are overlaps with the gex gene symbols, then you might have trouble down the line
# It is recommended to add something to make the labels unique e.g. "adt_CD4"
index_col_choice: 

# If providing 10X outputs, then the pipeline will load the filtered gex 10X outputs and the raw adt 10X counts
# we assume in most cases that we want to treat filtered gex barcodes as the "real" cells
# and we want out adt assays barcodes to match gex. In which case set subset_adt_barcodes_to_gex: True (which is also the default setting)
# if explicitly set to False, the full raw adt matrix will be loaded into the mudata obect
subset_adt_barcodes_to_gex: True

###  ADT QC metrics:
# as standard the following metrics are calculated for adt data
# per cell metrics:
# total_counts,log1p_total_counts,n_adt_by_counts,log1p_n_adt_by_counts
# if isotypes can be detected then the following are calculated also:
# total_counts_isotype,pct_counts_isotype
# choose which ones you want to plot here
adt_metrics_per_cell: total_counts,log1p_total_counts,n_adt_by_counts,pct_counts_isotype

# per antibody metrics
# n_cells_by_counts,mean_counts,log1p_mean_counts,pct_dropout_by_counts,total_counts,log1p_total_counts
# choose which ones you want to plot here:
adt_metrics_per_adt: total_counts,log1p_total_counts,n_cells_by_counts,mean_counts

# isotype outliers: one way to determine which cells are very sticky is to work out which cells have the most isotype UMIs
# associated to them, to label a cell as an isotype outlier, it must meet or exceed the following crietria:
# be in the above x% quantile by UMI counts, for at least n isotypes 
# (e.g. above 90% quantile UMIs in at least 2 isotypes)
identify_isotype_outliers: True
isotype_upper_quantile: 90
isotype_n_pass: 2
# TODO: work out how to plot this.

### Normalisation of ADT
# comma separated string of normalisation options
# options: dsb,clr
normalisation_methods: dsb


# it is important to note, if you choose to run the clr on a per channel basis, then it is not stored in the h5mu file.
# if you want to save the per channel normalised values set the following to True:
save_norm_prot_mtx: False
# During the integration pipeline, the dsb/clr normalisation will be rerun,
# across the whole dataset and saved in the h5mu object.
# this can also be acheived by leave the channel_col parameter blank. 

# DSB parameters:
# quantile clipping, even with normalisation, 
# some cells get extreme outliers which can be clipped as discussed https://github.com/niaid/dsb
# maximum value will be set at the value of the 99.5% quantile, applied per feature
quantile_clipping: True

# CLR parameters:
# margin determines whether you normalise per cell (as you would RNA norm), 
# or by feature (recommended, due to the variable nature of adts)
# 0 = normalise colwise (per feature)
# 1 = normalise rowwise (per cell)
clr_margin: 0

# ------------
# ATAC qc 
# ------------

# we require initializing one csv file per aggregated ATAC/multiome experiment.
# if you need to analyse multiple samples in the same project, aggregate them with the cellranger arc pipeline
# for multiome samples we recommend, specifying the 10X h5 input "10x_h5"
# per_barcode_metric is only avail on cellranger arc (multiome)

#is this an ATAC alone or a multiome sample?
is_paired: True
#this is NOT a multiome exp, but you have an RNA anndata that you would like to use for TSS enrichment, 
#leave empty if no rna provided
partner_rna: 
#if this is a standalone atac (is_paired: False), please provide a feature file to run TSS enrichment.
#supported annotations for protein coding genes provided
features_tss: #resources/features_tss_hg19.tsv
# binarize the peak count matrix?
binarize: False 
# normalize data and with which method? leave empty if no normalization needed, options are log1p and TFIDF
# This section will move to qc pipeline
normalize:
# if normalize is set to TFIDF, which flavour to use 
TFIDF_flavour: signac, logTF, logIDF 
#these will be used to plot and saved in the metadata
qc_metrics: n_genes_by_counts,total_counts,pct_fragments_in_peaks,atac_peak_region_fragments,atac_mitochondrial_reads,atac_TSS_fragments


# ------------
# Repertoire QC
# ------------
# Repertoire data will be stored in one modality called "rep", if you provide both TCR and BCR data then this will be merged, 
# but various functions will be fun on TCR and BCR separately
# Review scirpy documentation for specifics of data storage https://scverse.org/scirpy/latest/index.html

# compute sequence distance metric (required for clonotype definition)
# for more info on the following args go to 
# https://scverse.org/scirpy/latest/generated/scirpy.pp.ir_dist.html#scirpy.pp.ir_dist
# leave blank for defaults
ir_dist:
  metric:
  sequence:

# clonotype definition 
# for more info on the following args go to 
# https://scverse.org/scirpy/latest/generated/scirpy.tl.define_clonotypes.html#scirpy.tl.define_clonotypes
# leave blank for defaults
clonotype_definition:
  receptor_arms:
  dual_ir:
  within_group:

# ------------
# Plot QC metrics
# ------------

  
